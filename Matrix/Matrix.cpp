// matrixf.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"
#include "my_matrix.h"
#include "my_complex_matrix.h"

#include <iostream>

using std::cout;
using std::endl;

typedef LINALG::matrixf matrixf;
typedef LINALG::matrixd matrixd;
typedef LINALG_COMPLEX::matrix_cd matrix_cd;

/*
%%MatrixMarket matrix array      complex general
%-----------------------------------------------------
% Matrix generated by ZLATMR in LAPACK/TESTING/MATGEN
% on a Sun SPARCstation 10; library compiled with the
% SPARCworks 2.0.1 Fortran 77 compiler.
%-----------------------------------------------------
%   Parameters:
%          M  =   10
%          N  =   10
%       DIST  =    S
% (IN) ISEED  = 1082 1692 3162 2317
% (OUT)ISEED  = 2106 3882  699  117  (for next in sequence)
%        SYM  =    H
%       MODE  =    6
%       COND  =  0.1000E+01
%       DMAX  =  0.1000E+01  0.0000E+00
%      RSIGN  =    F
%      GRADE  =    N
%      MODEL  =    6
%      CONDL  =  0.1000E+01
%      MODER  =    6
%      CONDR  =  0.1000E+01
%     PIVTNG  =    N
%     SPARSE  = 0.00
%         KL  =    9
%         KU  =    9
%      ANORM  = -0.1000E+01
%       PACK  =    N
%-----------------------------------------------------
10 10

*/

complex<double> complex_arr[100]=
{
	{ -0.6874817824019530E+00,    0.0000000000000000E+00 },
	{0.9485357759247179E+00,    0.5229288009998854E+00},
	{0.2464840679619513E+00, - 0.7760725987039692E+00},
	{0.1118783562897718E+00 ,- 0.5641190933203930E+00},
	{0.6976130117763049E+00,    0.8587592809805855E+00},
	{0.7735332833277724E+00,    0.2351563845376958E+00},
	{0.7404090570665360E+00, - 0.8469138516370336E+00},
	{0.7526802703191109E+00, - 0.1556381576084291E+00},
	{0.1503959699603072E+00,    0.3576697341978488E+00},
	{0.9553080269574892E+00, - 0.7882091247066825E-01},
	{0.9485357759247179E+00, - 0.5229288009998854E+00},
	{-0.3817259615035979E+00,    0.0000000000000000E+00},
	{-0.6194356925069471E+00,    0.6419717263312208E-01},
	{0.8367826017324731E+00,    0.1663316857889967E+00},
	{0.8778931509749057E+00, - 0.6827109052537494E+00},
	{-0.2727345793331821E+00,    0.7028139184297046E+00},
	{0.5188107615920288E+00, - 0.4480896767260134E-01},
	{0.6909129876174873E+00,    0.4165982524534328E+00},
	{-0.5140752314410335E+00, - 0.6717586891969418E+00},
	{0.5967183986944704E+00, - 0.5302833806482354E+00},
	{0.2464840679619513E+00,    0.7760725987039692E+00},
	{-0.6194356925069471E+00, - 0.6419717263312208E-01},
	{-0.6346695146555632E+00,    0.0000000000000000E+00},
	{-0.5700599281313359E+00,    0.1711785507203771E+00},
	{0.2524623660613159E+00, - 0.7265396316844672E+00},
	{0.8826453648243913E+00,    0.4790859797913853E+00},
	{0.7106489111217300E+00, - 0.6266635028153829E+00},
	{0.2631247795259881E+00,    0.5913854822147400E+00},
	{0.5651801632633422E+00,    0.5300585515508018E+00},
	{-0.3959610978946486E+00,    0.3348637694186536E+00},
	{0.1118783562897718E+00,    0.5641190933203930E+00},
	{0.8367826017324731E+00, - 0.1663316857889967E+00},
	{-0.5700599281313359E+00, - 0.1711785507203771E+00},
	{-0.9611417410413239E+00,    0.0000000000000000E+00},
	{-0.1984475179386251E+00,    0.6441098879651221E+00},
	{0.7578580164299140E+00 ,- 0.9216736661261180E+00},
	{-0.3735571748255708E+00,    0.4366444520396371E+00},
	{-0.6482210827241417E+00,    0.8647203916369435E+00},
	{0.3727495139522219E+00,    0.1930927782246030E+00},
	{0.7514886002389360E+00,    0.1442075360264639E+00},
	{0.6976130117763049E+00, - 0.8587592809805855E+00},
	{0.8778931509749057E+00,    0.6827109052537494E+00},
	{0.2524623660613159E+00,    0.7265396316844672E+00},
	{-0.1984475179386251E+00, - 0.6441098879651221E+00},
	{-0.6023866934050304E+00,    0.0000000000000000E+00},
	{0.1458455900627342E-01, - 0.7030148552228539E+00},
	{-0.2041873779889372E+00,    0.7534189801415536E+00},
	{-0.9864294077140627E+00,    0.4967395465720514E+00},
	{-0.4999934883046464E+00,    0.7983346436233987E+00},
	{-0.4195862465910452E+00, - 0.1381102978804520E+00},
	{0.7735332833277724E+00, - 0.2351563845376958E+00},
	{-0.2727345793331821E+00, - 0.7028139184297046E+00},
	{0.8826453648243913E+00, - 0.4790859797913853E+00},
	{0.7578580164299140E+00,    0.9216736661261180E+00},
	{0.1458455900627342E-01,    0.7030148552228539E+00},
	{0.8888858439491472E+00,    0.0000000000000000E+00},
	{-0.3838089234294983E-01,    0.9544095224642533E+00},
	{0.8263280700754265E+00, - 0.7420877603999898E+00},
	{0.5470213531586481E+00,    0.2630678917927511E+00},
	{-0.8224553437601614E+00, - 0.7866433346706359E+00},
	{0.7404090570665360E+00,    0.8469138516370336E+00},
	{0.5188107615920288E+00,    0.4480896767260134E-01},
	{0.7106489111217300E+00,    0.6266635028153829E+00},
	{-0.3735571748255708E+00, - 0.4366444520396371E+00},
	{-0.2041873779889372E+00, - 0.7534189801415536E+00},
	{-0.3838089234294983E-01, - 0.9544095224642533E+00},
	{-0.9391941763824363E+00,    0.0000000000000000E+00},
	{0.8301584900851324E+00, - 0.4995288219458658E+00},
	{0.4653405462551135E+00,    0.3469201139000333E+00},
	{0.4865840495846285E+00,    0.4968883495435961E-01},
	{0.7526802703191109E+00,    0.1556381576084291E+00},
	{0.6909129876174873E+00, - 0.4165982524534328E+00},
	{0.2631247795259881E+00, - 0.5913854822147400E+00},
	{-0.6482210827241417E+00, - 0.8647203916369435E+00},
	{-0.9864294077140627E+00, - 0.4967395465720514E+00},
	{0.8263280700754265E+00,    0.7420877603999898E+00},
	{0.8301584900851324E+00,    0.4995288219458658E+00},
	{-0.1903276996736665E+00,    0.0000000000000000E+00},
	{-0.4032827295204058E+00,    0.9297115779825376E+00},
	{-0.9647425231409485E+00,    0.9691175500249969E+00},
	{0.1503959699603072E+00, - 0.3576697341978488E+00},
	{-0.5140752314410335E+00,    0.6717586891969418E+00},
	{0.5651801632633422E+00, - 0.5300585515508018E+00},
	{0.3727495139522219E+00, - 0.1930927782246030E+00},
	{-0.4999934883046464E+00, - 0.7983346436233987E+00},
	{0.5470213531586481E+00, - 0.2630678917927511E+00},
	{0.4653405462551135E+00, - 0.3469201139000333E+00},
	{-0.4032827295204058E+00, - 0.9297115779825376E+00},
	{-0.2782136800575401E+00,    0.0000000000000000E+00},
	{0.1672696111427356E+00, - 0.2878310330644496E-01},
	{0.9553080269574892E+00,    0.7882091247066825E-01},
	{0.5967183986944704E+00,    0.5302833806482354E+00},
	{-0.3959610978946486E+00, - 0.3348637694186536E+00},
	{0.7514886002389360E+00, - 0.1442075360264639E+00},
	{-0.4195862465910452E+00,    0.1381102978804520E+00},
	{-0.8224553437601614E+00,    0.7866433346706359E+00},
	{0.4865840495846285E+00, - 0.4968883495435961E-01},
	{-0.9647425231409485E+00, - 0.9691175500249969E+00},
	{0.1672696111427356E+00,    0.2878310330644496E-01},
	{0.7490920983257823E+00,    0.0000000000000000E+00}
};


matrixf  dat_M_LU = {
	{ 3, 5, 2 },
	{ 0, 8, 2 },
	{ 6, 2, 8 }
};
matrixf  dat_M_tri = {
	{ 1, -0.25, -0.25, 0 },
	{ -0.25, 1, 0, -0.25 },
	{ -0.25, 0, 1, -0.25 },
	{ 0, -0.25, -0.25, 1 }
};
matrixf  dat_L = {
	{ 2, 0, 0 },
	{ 1, 4, 0 },
	{ 7, -3, 5 }
};

matrixf  dat_G = {
	{ -1, 1, 2 },
	{ 3, -1, 1 },
	{ -1, 3, 4 }
};

matrixf  dat_A_1 = {
	{ 6, 4, 1, 1 },
	{ 4, 6, 1, 1 },
	{ 1, 1, 5, 2 },
	{ 1, 1, 2, 5 }
};
matrixf  dat_A = {
	{ 4, 2, 14 },
	{ 2, 17, -5 },
	{ 14, -5, 83 }
};

matrixf  dat_Hess_QR2 = {
	{ 5.0f, 1.0f, 2.0f, 0.0f, 4.0f },
	{ 1.0f, 4.0f, 2.0f, 1.0f, 3.0f },
	{ 2.0f, 2.0f, 5.0f, 4.0f, 0.0f },
	{ 0.0, 1.0, 4.0, 1.0, 3.0 },
	{ 4.0, 3.0, 0.0, 3.0, 4.0 }
};
float  dat_Hess_QR1_2[4][4] = {
	{ 6.0f, -sqrt(18.0), 0.0f, 0.0f },
	{ -sqrt(18), 7.0, sqrt(2.0), 0.0f },
	{ 0.0f, sqrt(2.0), 6.0f, 0.0f },
	{ 0.0f, 0.0, 0.0f, 3.0f }
};
matrixf dat_Hess_QR1 = dat_Hess_QR1_2;
matrixf  dat_Hess_3 = {
	{ 5.0, 4.0, 3.0, 2.0, 1.0 },
	{ 1.0, 4.0, 0.0, 3.0, 3.0 },
	{ 2.0, 0.0, 3.0, 0.0, 0.0 },
	{ 3.0, 2.0, 1.0, 2.0, 5.0 },
	{ 4.0, 2.0, 1.0, 4.0, 1.0 }
};
matrixf  dat_Hess_2 = {
	{ 6.0, 1.0, -2.0, 19.0, 4.0 },
	{ 1.0, 4.0, 2.0, 1.0, 3.0 },
	{ 7.0, 12.0, 5.0, 11.0, -1.0 },
	{ -3.0, 21.0, 4.0, 1.0, 3.0 },
	{ 4.0, 6.0, -1.0, 3.0, 7.0 }
};
matrixf  dat_Hess_0 = {
	{ 4.0, 1.0, -1.0, 2.0 },
	{ 1.0, 4.0, 1.0, -1.0 },
	{ -1.0, 1.0, 4.0f, 1.0f },
	{ 2.0f, -1.0, 1.0f, 4.0f }
};
matrixf mat_QR_2 = {
	{ 4, 2, 2, 1 },
	{ 2, -3, 1, 1 },
	{ 2, 1, 3, 1 },
	{ 1, 1, 1, 2 }
};

matrixf mat_QR_1 = {
	{ 1, 3, 0, 0 },
	{ 3, 2, 1, 0 },
	{ 0, 1, 3, 4 },
	{ 0, 0, 4, 1 }
};


matrixf list_of_matrices[] = { mat_QR_1, mat_QR_2, dat_Hess_0, dat_Hess_2, dat_Hess_3, dat_Hess_QR1, dat_Hess_QR2, dat_A, dat_A_1, dat_G, dat_M_tri };







void Test_Complex_Matrix()
{
	matrix_cd m(4, 4);

	for (int r = 0; r < 4; r++)
	{
		for (int c = 0; c < 4; c++)
		{
			m(r, c) = complex<float>( LINALG_COMPLEX::RandomFloat(0.0, 10.0) ,  LINALG_COMPLEX::RandomFloat(0.0, 10.0) );
		}
	}

	cout << endl;

	m.print(3);

	matrix_cd m2(4, 4);

	for (int r = 0; r < 4; r++)
	{
		for (int c = 0; c < 4; c++)
		{
			m2(r, c) = complex<float>(LINALG_COMPLEX::RandomFloat(0.0, 10.0), LINALG_COMPLEX::RandomFloat(0.0, 10.0));
		}
	}

	cout << endl;

	m2.print(3);

	matrix_cd m3 = m * m2;
	matrix_cd m4 = m2 * m;

	matrix_cd m5 = m4 - m3;

	matrix_cd m6 = m5 * (m + m2) - 2 * (m4 * (m3 + m));

	cout << endl;
	cout << "printing m3 = m * m2" << endl;
	m3.print(3);
	cout << endl;
	cout << "printing m3 / 2" << endl;
	matrix_cd m7 = m3 / 2.0;
	m7.print(3);

	cout << endl;
	cout << "printing m4 = m2 * m" << endl;
	m4.print(3);
	
	cout << endl;
	cout << "printing m5 = m4 - m3" << endl;
	m5.print(3);

	cout << endl;
	cout << "printing m6 = m5 * (m + m2) - 2 * (m4 * (m3 + m))" << endl;
	m6.print(3);

	cout << endl;
	cout << "printing m6 transposed" << endl;
	m6.transpose();
	m6.print(3);

	cout << endl;
	cout << "printing m ReduceToUpperTriangularForm" << endl;
	double sign = 1;
	m.ReduceToUpperTriangularForm(sign);

	//m.Round_to_N_digits(5);
	m.print(3);
	for (int i = 0; i < 1; i++)
	{

		matrix_cd m9(10, 10);

		for (int r = 0; r < 10; r++)
		{
			for (int c = 0; c < 10; c++)
			{
				m9(r, c) = complex_arr[r*10 + c];
			}
		}
		/*matrix_cd m9(4, 4);

		for (int r = 0; r < 4; r++)
		{
			for (int c = 0; c < 4; c++)
			{
				m9(r, c) = LINALG_COMPLEX::RandomComplex<double>(-10.0, 10.0);
			}
		}*/
		cout << endl;
		cout << "printing m9" << endl;
		m9.print(2);

		cout << endl;
		cout << "Is the matrix Hermitian?" << endl;
		if (m9.IsHermitian())
			cout << "true" << endl;
		else cout << "false" << endl;

		cout << endl;
		cout << "printing m9 inverted" << endl;
		matrix_cd Ic1 = m9;
		matrix_cd m9_inv = Ic1.Invert_Crout();
		m9_inv.print(2);

		cout << endl;
		cout << "printing inverse after newton iteration" << endl;
		matrix_cd new_m9_inv = m9.Newtons_Iteration_for_Inverse(m9_inv, 20);
		new_m9_inv.print(2);

		//m9_inv.ClipToZero(0.0000001);
		//m9.ClipToZero(0.0000001);

		cout << endl;
		cout << "printing new_m9_inv * m9 " << endl;
		matrix_cd I_complex = m9_inv * m9;
		I_complex.print(2);

		cout << endl;
		cout << "printing  m9 *new_m9_inv  " << endl;
		matrix_cd I_complex2 = m9 *m9_inv;
		I_complex2.print(2);
	//	complex<double> R_01 = m9(0, 0) * m2_inv(0, 1) + m9(0, 1) * m2_inv(1, 1) + m9(0, 2)* m2_inv(2, 1) + m9(0, 3)* m2_inv(3, 1);
		cout << endl;
	//	cout << "printing  element 0,1 " << endl;
		cout << "     determinant: " << m9.Determinant() << endl;


		cout << endl;
		cout << "Householder test ..." << endl;
		m9.Householder_Tridiagonalize();
		m9.print(3);


	}

	cout << endl;
	cout << "=================================================" << endl;
	cout << "Testing Gauss Elimination" << endl;
	matrix_cd A(3,3);

	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 3; j++)
		{
			A(i, j) = complex<float>(dat_M_LU(i, j), LINALG_COMPLEX::RandomFloat(-4, 5));
		}
	}
	
	;

	m.SwapRow(0, 1); // these were swapped

	cout << endl;
	cout << "Printing A" << endl;
	A.print(4);

	matrix_cd b(3, 1);
	b(0, 0) = complex<float>( -7, 3);
	b(1, 0) = complex<float>(8, 4);
	b(2, 0) = complex<float>( 26, 14);

	cout << endl;
	cout << "Printing b" << endl;
	b.print(4);

	cout << endl;
	cout << "Solvng the system A x = b for x" << endl;
	cout << endl;

	matrix_cd sol = A.Gauss_Elimination(b);

	cout << "printing solution" << endl;

	sol.print(4);

	cout << endl;
	// still broken, check on here 
	// http://matrix.reshish.com/inverse.php
	//complex<double> __a[6][6]
		matrix_cd test_inv = {
		{ { 5, 4 }, { 3, -2 }, { 4, 4 }, {-6, 2},   {-2, 4}, {2, -8} },
		{  {2 + 2},	{ 3,  0 }, {-7 + 2}, {12 ,-1 },	{3, 2},	 {1 ,1}  },
		{ { 5, 4 }, { 0, 0 }, { 9, 2 }, { 0, 0 }, { 0, 0 }, { 0, 0 } },
		{ { 0, 0 }, { 0, 0 }, { 0, 0 }, {-4, -7}, {2, -1 }, {2,  2}  },
		{ {17, 19.6},	{4, 3},{ -2, -1},	{1,1 }, {-14,  3},	{8 ,-4}},
		{ { -5, -3 }, { 8, 2 }, { 4, -3 }, { -3, -5 }, { 15, 2 }, { 1, 0 } }
	};

	//matrix_cd test_inv(6, 6);
	/*for (int i = 0; i < 6; i++)
		for (int j = 0; j < 6; j++)
			test_inv(i, j) = __a[i][j];*/
	cout << endl;
	test_inv.print(3);
	matrix_cd test_inv_copy = test_inv;
	matrix_cd test_inv_inv = test_inv.Gauss_Jordan();
	cout << endl;

	cout << endl;
	cout << "printing test_inv_inv" << endl;
	test_inv_inv.print(3);

	matrix_cd test_inv_inv2 = test_inv*test_inv_inv;//.Gauss_Jordan();

	cout << endl;
	test_inv_inv2.print(5);

	cout << "Clearly this is just plain wrong ... is this numerical stability or just plain super-wrongness?"<<endl;
	cout << endl; 
	cout << "Testing Crout inverse" << endl;

	matrix_cd crout_inv = test_inv_copy.Invert_Crout();
	crout_inv.print(4);

	cout << "printing A*A_inv" << endl;

	matrix_cd crout_ident = test_inv_copy * crout_inv;
	crout_ident.print(4);

	matrix_cd crout_inv_copy = crout_inv;
	cout << "Conclusion ? The crout method successfully computes the inverse by solving the system Ax = b " << endl;
	cout << "with b x as a column of the inverse and b as the corresponding column of the identity matrix" << endl;
	//cout << "perhaps it is possible to fix the tiny numerical errors" << endl;
	cout << endl;
	cout << "Testing Newtown Iteration for inverse" << endl;
	crout_inv = test_inv_copy.Newtons_Iteration_for_Inverse(crout_inv, 20);
	crout_inv.print(-1);

	
	matrix_cd diff = crout_inv_copy - crout_inv;
	cout << "Printing difference after newton iteration" << endl;
	diff.print(-1);

	crout_ident = test_inv_copy * crout_inv;
	cout << "Printing closer identity" << endl;
	crout_ident.print(4);



	cout << endl;
	cout << "Testing newton iteration on Gauss Elimination matrix" << endl;
	test_inv.Newtons_Iteration_for_Inverse(test_inv_inv, 20);

	test_inv_inv2 = test_inv*test_inv_inv;//.Gauss_Jordan();

	cout << endl;
	test_inv_inv2.print(5);

	cout << endl << "this is clearly the identity matrix ... printing the new inverse " << endl;




	matrix_cd H_1 = test_inv_copy;
	matrix_cd H_2 = H_1;
	//cout << "Printing the Frobenius Norm of the matrix " << endl;
	cout << endl << "Householder_Tridiagonalizen" << endl;
	H_1.Householder_Tridiagonalize();
	H_1.print(4);

	cout << endl << "Householder_Tridiagonalizen_wiki (current implementation of the wikipedia QR algorithm)" << endl;
	H_2.Householder_Tridiagonalize_wiki();
	H_2.print(4);
	cout << endl;
	cout << "Clearly there is an improvement here ... this version computes QR not PHP" << endl;


}



void TestingProcedure_Householder_Hessenburg_QR(matrixf &H_)
{
	cout << endl;
	cout << "===================================================" << endl;
	// using the wisdom from
	// http://www.ams.org/journals/mcom/1969-23-108/S0025-5718-1969-0258255-3/S0025-5718-1969-0258255-3.pdf
	// I have decided to only use Housedholder methods
	// this matrix shows the evidence of the stability issue ...


	cout << endl;
	cout << "Printing the initial matrix" << endl;

	H_.print(3);

	cout << endl;

	matrixf H__3 = H_;

	cout << endl;
	cout << "Applying Householder Algorithm (required before QR algorithm" << endl;
	cout << endl;
	
	std::cin.clear();
	char sel1;
	std::cin.get(sel1);

	
//	if (sel1 == 'y' || sel1 == 'Y')
//	{
		H__3.Householder_Tridiagonalize();

		cout << endl;
		cout << "Printing the matrix afer Householder reduction" << endl;
		cout << endl;

		H__3.print(4);
//	}

	//	float sign = 1;
		//matrixf test = list_of_matrices[matrix_selection];
	//	H__3.ReduceToUpperHessenburg(sign);
	//	cout << endl;
	//	H__3.print(3);

	cout << endl;
	
	cout << endl;
	cout << "Apply QR Algorithm ? (Y/N) " << endl;
	cout << endl;

	std::cin.clear();
	char sel;
	std::cin.get( sel);

	if (sel == 'y' || sel == 'Y')
	{
		matrixf eigen_values(H__3.NumCols(), 2);

		H__3.QR_algorithm(eigen_values);

		cout << endl;
		cout << "Printing the matrix afer QR algorithm" << endl;
		cout << endl;

		H__3.print(4);

		cout << endl;
		cout << "printing the eigen values" << endl;
		cout << endl;

		eigen_values.print(3);
	}

	cout << endl;
	cout << endl;
}



void TestGaussElimination_1()
{
	cout << "=================================================" << endl;
	cout << "Testing Gauss Elimination" << endl;
	matrixf m = dat_M_LU;
	
	m.SwapRow(0, 1); // these were swapped

	cout << endl;
	cout << "Printing A" << endl;
	m.print(4);

	matrixf b(3, 1);
	b(0, 0) = -7;
	b(1, 0) = 8;
	b(2, 0) = 26;

	cout << endl;
	cout << "Printing b" << endl;
	b.print(4);

	cout << endl;
	cout << "Solvng the system A x = b for x" << endl;
	cout << endl;

	matrixf sol = m.Gauss_Elimination(b);

	cout << "printing solution" << endl;

	sol.print(4);

	cout << endl;
}

void TestGaussElimination_2()
{
	cout << "=================================================" << endl;
	cout << "Testing Gauss Elimination 2" << endl;

	matrixf m2 = dat_A;

	cout << endl;
	cout << "printing A2" << endl;

	m2.print(4);

	matrixf b2(3, 1);
	b2(0, 0) = 14;
	b2(1, 0) = -101;
	b2(2, 0) = 155;

	cout << endl;
	cout << "Printing b" << endl;

	b2.print(4);


	cout << endl;
	cout << "Solvng the system A x = b" << endl;

	matrixf sol2 = m2.Gauss_Elimination(b2);

	cout << endl;
	cout << "printing solution (x) " << endl;
	sol2.print(4);
}

void TestGaussSeidel()
{
	cout << endl;
	cout << "=================================================" << endl;
	cout << endl;

	cout << "tesing Gauss Seidel" << endl;

	matrixf M = dat_M_tri;

	cout << endl;
	cout << "Printing M" << endl;
	M.print(4);

	cout << endl;

	if (M.IsSymmetric()) cout << "M is Symmetric" << endl;
	if (M.IsPositiveDefinite()) cout << "M is positive definite" << endl;

	matrixf B(4, 1);

	B(0, 0) = 50;
	B(1, 0) = 50;
	B(2, 0) = 25;
	B(3, 0) = 25;

	cout << endl;
	cout << "Printing B" << endl;
	B.print(4);

	cout << endl;
	cout << "Printing Initial Approximation x0" << endl;

	matrixf initial_approx(4, 1);
	initial_approx(0, 0) = 100;
	initial_approx(1, 0) = 100;
	initial_approx(2, 0) = 100;
	initial_approx(3, 0) = 100;

	cout << endl;
	initial_approx.print(4);
	cout << endl;

	cout << "Solvng the system A x = b with A = M, b = B" << endl << " tolerance = 0.1, MAX_ITERATIONS = 200" << endl;
	M.transpose();

	matrixf SOL = M.Gauss_Seidel(B, initial_approx, 0.1, 200);

	cout << endl;
	cout << "solution" << endl;
	SOL.print(4);
}




void Test_Doolittle_LU_System()
{
	cout << endl;
	cout << "=================================================" << endl;
	cout << "Testing Doolittle LU decomposition" << endl;
	cout << endl;

	matrixf L_2(3, 3);
	L_2.Identity();

	matrixf U_2(3, 3);





	matrixf M_ = dat_M_LU;



	cout << "Printing M_" << endl;
	M_.print(4);
	cout << endl;

	M_.LU_Decomposition_Doolittle(L_2, U_2);

	cout << endl;
	cout << "Printing L" << endl;
	L_2.print(4);


	cout << endl;
	cout << "Printing U" << endl;
	U_2.print(4);
	cout << endl;
	matrixf LU = L_2 * U_2;

	cout << "Printing L * U" << endl;
	LU.print(4);

	cout << endl;
	cout << "=================================================" << endl;
	cout << "Testing Doolittle system solver" << endl;
	cout << endl;

	matrixf B_lu(3, 1);
	B_lu(0, 0) = 8;
	B_lu(1, 0) = -7;
	B_lu(2, 0) = 26;

	matrixf X_lu = M_.Solve_System_LU(L_2, U_2, B_lu);
	cout << "1. Using previously computed LU matrices" << endl;
	cout << "Printing solution" << endl;
	X_lu.print(4);

	B_lu(0, 0) = 8;
	B_lu(1, 0) = -7;
	B_lu(2, 0) = 26;

	matrixf X_lu2 = M_.Solve_System_Doolittle(B_lu);
	cout << endl;
	cout << "2. Using internally computed LU matrices" << endl;
	cout << "Printing solution" << endl;
	X_lu2.print(4);

}
void TestCrout_LU_Method()
{
	cout << "=================================================" << endl;
	cout << "Testing LU Decomposition Crout's Method" << endl;
	cout << endl;
	matrixf L_3(3, 3);
	matrixf U_3(3, 3);

	matrixf M_ = dat_M_LU;

	matrixf A3 = M_;
	M_.LU_Decomposition_Crout(L_3, U_3);

	cout << "Printing L" << endl;
	L_3.print(4);

	cout << endl;
	cout << "Printing U" << endl;
	U_3.print(4);

	cout << endl;
	cout << "Printing L*U" << endl;
	matrixf crout = L_3 * U_3;
	crout.print(4);

	matrixf B_lu(3, 1);
	B_lu(0, 0) = 8;
	B_lu(1, 0) = -7;
	B_lu(2, 0) = 26;

	cout << endl;
	cout << "=================================================" << endl;
	cout << "Testing Crout system solver" << endl;
	cout << endl;
	cout << "1. Using previously computed LU matrices" << endl;

	matrixf X_crout_lu = M_.Solve_System_LU(L_3, U_3, B_lu);
	cout << "Printing Solution" << endl;
	X_crout_lu.print(4);

	cout << endl;
	cout << "2. Using internally computed LU matrices" << endl;
	matrixf X_crout_lu2 = M_.Solve_System_Crout(B_lu);
	cout << "Printing Solution" << endl;
	X_crout_lu2.print(4);
}
void Testing_Determinant()
{
	matrixf M_ = dat_M_LU;

	cout << endl;
	cout << "=================================================" << endl;
	cout << "Testing Det" << endl;

	matrixf M_2 = M_;
	cout << M_.Det_3x3(0, 0) << "    " << M_2.Determinant();
	cout << endl;

}



void Test_TriangularSystemSolvers()
{
	cout << endl;
	cout << "=================================================" << endl;
	cout << "Lower triangular system test." << endl;


	matrixf L = dat_L;


	cout << endl;
	cout << "Printing L" << endl;
	L.print(4);

	cout << endl;


	matrixf y(3, 1);

	matrixf b3(3, 1);

	b3(0, 0) = 14;
	b3(1, 0) = -101;
	b3(2, 0) = 155;

	cout << endl;
	cout << "Printing B" << endl;
	b3.print(4);

	cout << endl;



	matrixf M = dat_M_tri;


	M(3, 0) = 0;
	M(3, 1) = -0.25;
	M(3, 2) = -0.25;
	M(3, 3) = 1;
	M.Solve_Lower_TriangularSystem(L, y, b3);
	cout << "printing solution" << endl;
	y.print(4);
}

void TestUpperTriangularSolver(){

	cout << endl;
	cout << "=================================================" << endl;
	cout << "Testing Upper Triangular Solver" << endl;

	matrixf L = dat_L;
	matrixf M = dat_M_tri;

	L.transpose();

	cout << endl;
	cout << "Printing U" << endl;
	L.print(4);

	cout << endl;

	matrixf y(3, 1);

	matrixf b3(3, 1);

	b3(0, 0) = 14;
	b3(1, 0) = -101;
	b3(2, 0) = 155;

	matrixf x(3, 1);

	M.Solve_Upper_TriangularSystem(L, x, y);


	cout << "printing solution" << endl;
	x.print(4);
}
void TestCholesky(){


	cout << endl;
	cout << "=================================================" << endl;
	cout << "testing cholesky" << endl;

	matrixf y(3, 1);

	matrixf b3(3, 1);

	b3(0, 0) = 14;
	b3(1, 0) = -101;
	b3(2, 0) = 155;

	matrixf A = dat_A;
	matrixf A2 = A;
	
	cout << endl;
	cout << "Printing A" << endl;
	A.print(4);
	cout << endl;

	cout << "Printing b" << endl;
	b3.print(4);
	cout << endl;

	cout << "To Solve Ax = b" << endl;
	matrixf c = A.Cholesky(b3);
	c.print(4);


}


void Testing_GaussJordan_Elimination()
{
	cout << endl;
	cout << "=================================================" << endl;
	cout << "Testing matrixd Inversion via Gauss-Jordan Elimination " << endl;


	matrixf G = dat_G;


	cout << endl;
	cout << "printing G" << endl;
	G.print(4);


	matrixf old_G = G;
	matrixf G2 = G.Gauss_Jordan();
	cout << endl;
	cout << "printing G2" << endl;
	G2.print(4);

	cout << endl;
	cout << "printing G" << endl;
	G.print(4);
	cout << endl;


	cout << endl;
	cout << "printing G2 * old_G" << endl;
	matrixf what = old_G * G2;
	what.print(4);
	cout << endl;
	cout << "Close enough ignoring numbers below 1e-010" << endl;
}


void Testing_Householder_Tridiagonalize()
{
	matrixf A_ = dat_A_1;
	cout << endl;
	cout << "=================================================" << endl;
	cout << "Testing Housholder Tridiagonalization" << endl;
	cout << endl;
	cout << "printing A_" << endl;
	A_.print(4);

	A_.Householder_Tridiagonalize();


	cout << endl;
	cout << "printing A_ after procedure" << endl;
	A_.print(4);


	cout << endl;
	cout << "printing A_ after clipping to 2e-06 " << endl;
	A_.ClipToZero(2e-06);
	A_.print(4);

}

void Test_Transposition()
{

	matrixf m = dat_M_tri;
	m.print(2);
	m.transpose();
	cout << endl << endl;
	m.print(2);
	cout << endl << endl;

	float dat__[4][3] = {
		{ 2, 1, 3 },
		{ 4, 5, 6 },
		{ 6, 5, 4 },
		{ 3, 2, 1 }
	};

	matrixf b = {
		{ 2, 1, 3 },
		{ 4, 5, 6 },
		{ 6, 5, 4 },
		{ 3, 2, 1 }
	};
	//for (int i = 0; i < 4; i++)
	//	for (int j = 0; j < 3; j++)
	//		b(i, j) = dat__[i][j];

	b.print(2);
	//b.transpose();
	cout << endl << endl;


	//	matrixf c = m * b;

	//	c.print(2);

	cout << endl << endl;
	b.transpose();
	b.print(2);
	cout << endl << endl;

	matrixf d = m*b;

	d.print(2);
	cout << endl << endl;
}


void Test_QR()
{
	int matrix_selection;

	cout << "printing list of matrices " << endl;
	for (int i = 0; i < 11; i++)
	{
		cout << (char)('A' + i) << " = " << endl << endl;

		list_of_matrices[i].print(2);
		cout << endl << endl;
	}

	cout << "Select a matrix from the above (A - K)" << endl;

	char sel;
	std::cin.clear();

	std::cin.get(sel);

	if (sel >= 'A' && sel < 'A' + 11)
	{
		cout << "You Selected: " << sel << endl;
		matrix_selection = sel - 'A';

		//list_of_matrices[matrix_selection].print(2);
		cout << "Testing Housholder algorithm and QR algorithm " << endl;

		TestingProcedure_Householder_Hessenburg_QR(list_of_matrices[matrix_selection]);



	}
}

int main(int argc, char* argv[])
{







		

	
	//Testing_Householder_Tridiagonalize();














//	cout << endl;
//	cout << "=================================================" << endl;
//	cout << "matrixf Multiplication A * A2" << endl;




/*	TestGaussElimination_1();
	TestGaussElimination_2();

	TestCholesky();
	TestCrout_LU_Method();

	TestGaussSeidel();
	Test_TriangularSystemSolvers();




	Test_Transposition();

	*/

	Test_Complex_Matrix();
		return 0;
}

